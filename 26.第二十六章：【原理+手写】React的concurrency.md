# 原理+手写】React 的 concurrency

React 将渲染流程分成了两个阶段：

- render：负责将需要渲染的组件【首次渲染就是 App 组件，更新阶段就是哪个组件需要更新就是哪个组件】的内部逻辑以及 react 的内部逻辑进行执行，并最终得出一份 fiber 清单【记录了最终要展示给用户看的真实 dom 树要是什么样的，要增加哪些 dom，要单纯更新的 dom】
  -commit：负责将 fiber 清单转换为真实 dom 就 ok 了【非常非常非常简单而且常规的工作，压根没有什么逻辑】所以 commit 阶段的工作百分之九十九点九的项目里是可以在一帧【16ms】内执行玩的

我们需要对 render 阶段做一点小手脚

- requestAnimationFrame：一帧内必定要执行的函数

```js
requestAnimationFrame(cb); // 这个cb会在浏览器的每一帧重排前都会执行
```

- requestIdleCallback：每一帧还有剩余时间的时候执行

```js
requestIdleCallback(cb); // 这个cb会在每一帧还有多余时间的时候执行
```

我们来探究一下 render 阶段的时候用户会看到什么？

首次渲染：

- render 阶段用户看到的是什么？白屏 2 秒钟之内是都能被接受 用户可不可以和页面交互？ 【分情况】
  - 整个页面都是 React 写的，而且只有一个根组件，这种情况用户是没法和页面交互的，正常
  - 整个页面只有一部分是由 react 接管和管理的，或者说整个页面有多个根组件【多个 react 容器】，这种情况用户是可以和页面交互的，因为不被 react 所管理的地方可能已经渲染出来了，正常的

更新时：

- render 阶段用户看到的是什么？是不是更新前的哪个画面，这个时候用户可以和页面交互

用户都没法和页面交互 他怎么造成掉帧？可以造成掉帧【但是由于界面本来就是白屏，用户压根感知不到掉帧】

如果时第二种情况就意味着 当前被 react 接管的这一块地方还在工作【js 引擎在工作】，但是用户可以直接和该区域以外的其他 dom 进行交互 必然会造成掉帧

那么用户的输入事件就丢失了【这就是我们要处理的】

更新时用户已经可以看到之前的画面了，那就意味着可以交互，可以交互 这时候你的 render 还在工作中，但是用户已经开始交互了，那是不是又必然掉帧了

**那现在我们来走一条思路，既然说用户的输入没法被响应是因为掉帧导致的，那掉帧又是因为某一帧的执行时间太过长导致的，而在 react 里，掉帧的情况无非就是因为 render 阶段的逻辑太多导致的**

react 是不是一个一个的 react 元素拼成的？App 没写的一个都是一个 react 元素【通过 React.createElement 创建的就是 react 元素】

这些成千上万个 react 元素组合在一起就成为庞大的 render 阶段要做的事情 那我们把他们拆开

乐高 小积木 堆成一个大房子 我这个大房子进门可能进不来，那我把他拆成一个一个乐高的小零件，是不是就可以过去了

通过 createElement 返回的就已经是一个 react 元素对象了对不对，就算你是一个组件，是不是也会被编译成 createElement，只不过你的 type 值不一样 console.log("App")

根组件是 App{type:App function,children:[]}

function Counter(){

}
