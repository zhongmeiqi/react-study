# 【原理】React 事件机制解析

非常重要！！！

工作：

1. 假设你使用的是 React17 以前的 react 版本 react16.8，那么你可能会遇到一些关于事件上的问题 以及相关库的兼容性的问题，如果你不懂事件机制，那你没法解决

面试：

1. 目前只要涉及到 react 的面试题【大厂 2W 起必问】：事件机制，fiber 架构、react 调度机制、优先级概念、commit 以及 render 两个阶段以及 hooks 原理

首先，React 的 JSX 写的代码不是真实 dom 首先被 babel 编译成 React.createElement 它会 编译 执行，从而在页面中生成真实 dom

其次，所有的标签属性都不是真实 dom，而是会被 react 进行处理，最终反映到真实的 dom 身上去

addEventListener()给每个元素绑定成百上千的事件是一个多么浩大的工程，如果把时间都花在绑顶到确定的元素身上，则无法进行动态监听。
所以要用【事件委托】，事件委托是可以进行动态监听！

假设我现在有 1000 个 dom，与其我绑定 1000 个 dom 事件，不如我给这 1000 个 dom 的父级绑定事件，给父级绑定的话，只需要绑定一个事件就 ok 了，**event.target--->指向真正触发事件的对象**

**react 为了节约性能以及实现动态监听，react 使用事件委托的机制**

react 把事件绑定在了对应的 root 元素上，当某个真实 dom 触发事件以后，dom 事件会随着事件冒泡，一直冒到 root 元素上，root 元素对应的事件处理函数又可以通过 event.target 知道真正触发事件的元素是谁

那其实就意味着 对应的 jsx 所转化的真实 dom 身上不会绑定任何的真实事件，react 会把 jsx 上所书写的对应的和事件有关的标签属性收集起来 找个地方存起来

最终真实 dom 在页面生成，当我们点击对应的真实 dom 时，事件会冒泡，事件冒泡是不需要绑定真实 dom 事件也会冒泡的，最终会冒泡到 root，然后 root 来进行事件的处理。

## 第二个重点 react 的事件池机制 【在 react 17 以后是不会发生了，react 17 以后取消了事件池机制】 旧文档搜 event pooling

1. react 里的标签属性事件 对应的 event 是哪里来的？【react 捏给你的，和真实 dom 没有半毛钱关系】
2. 在 16.8 以及之前的版本 react 为了更厚的性能考虑会尝试重用事件
3. react 会保存引用，只是修改对应的属性值

**基于 React 的事件池机制，只要你公司用的还是 17 以下的代码，你都要注意不要在异步环境下访问事件源对象的属性（因为会置空 null）**
发现 event.xxx 变成 null 了，就要考虑是不是因为事件池机制的影响。

不小心写进异步场景了 自己还没注意 同时访问属性是 null 了

如果你非得要在 react16.8 去异步访问 event，也有办法，react 说你调用：e.persist()，那就会取消事件池的重用机制

